#function to read fasta and create a list of sequences
#running: python3 ec_query2.py -e eclist.txt -f EL_zorfome2.fasta -q longa.ko.txt
#running: python3 ec_query2.py -p ath00900 -f EL_zorfome2.fasta -q longa.ko.txt
print("usage:\n")
print("python ECquery.py -e eclist.txt -q query.ko.txt -f query.fasta\nor\npython ECquery.py -p ath00900 -q query.ko.txt -f query.fasta\n")
print("This script queries EC numbers and returns a fasta of hits.")
print("The input is a list of EC numbers, the query.co file generated by KAAS, and ENZYMES.txt provided with the script.")
print("Please, enter the EC list (-e) or pathway (-p) and the fasta file to fish for sequences (-f)")
print("Query file name (-q) is optional, default is query.ko.txt")


import argparse
import os
from Bio import SeqIO
#import pandas as pd
#import pickle
from bioservices.kegg import KEGG
from collections import OrderedDict
from collections import defaultdict

parser = argparse.ArgumentParser(description='How to use argparse')
parser.add_argument('-e', '--EClist', help='FASTA eclist', default='eclist.txt')
parser.add_argument('-q', '--queryKO', help='query.ko filename', default='query.ko.txt')
parser.add_argument('-p', '--pathway', help='pathway', default='none')
parser.add_argument('-f', '--fasta', help='Accession rename key file', required=True)

args = parser.parse_args()

eclist = args.EClist
fasta = args.fasta
queryKO = args.queryKO
pathway = args.pathway

print("EC list file: %s; sequences will be extracted from: %s" %(eclist, fasta))

#first, dictionaries of ECs and their ortholog groups is made
#ortholog groups are called from ec_d, definitions from ECdef_d
#retrieve up to date list visiting: http://rest.kegg.jp/list/ko
infile = open('all_enzymes_kegg.txt')
lines = infile.read()
infile.close()

ENZYMES = lines.split('\n')

ec_d = {}
ECdef_d = {}

for line in ENZYMES:
	ko = line.split()[0][3:]
	definition = ' '.join(line.split()[1:])
	if '[EC:' in line:
		EC = line.split('[EC:')[1]
		definition = definition.split('[EC:')[0]
		if ' ' in EC:
			moreEC = EC.split()
			for item in moreEC:
				if item in ec_d:
					ec_d[item].append(ko)
					ECdef_d[item].append(definition)
				else:
					ec_d[item]=[ko]
					ECdef_d[item]=[definition]
	else:
		EC = line.split()[1]
		EC = EC.split(';')[0]
	if ' ' in EC:
		pass
	else: 
		if EC in ec_d:
			ec_d[EC].append(ko)
			ECdef_d[EC].append(definition)
		else:
			ec_d[EC]=[ko]
			ECdef_d[EC]=[definition]
"""
pickle.dump(ec_d, open('ec_d.txt', 'wb'))
#d = pickle.load(open('ec_d.txt', 'rb'))

pickle.dump(ECdef_d, open('ECdef_d.txt', 'wb'))

"""
#here a list of ECs is made to be searched for - if pathway is defined
if args.pathway != 'none':
	output = open('eclist.txt', 'w')

	kegg = KEGG()
	pathway = kegg.get(args.pathway)
	dict_data = kegg.parse(pathway)

	for value in dict_data['GENE'].values():
		EC = value.split('[EC:')[1]
		EC = EC.replace(']', '')
		EC = EC.replace(' ', '\n')
		output.write(EC + '\n')
	print("eclist.txt written")
	output.close()

#here query.ko.txt is opened and for each orthology group respective contigs are saved to kos_d
infile = open(queryKO)
inquery = infile.read()
infile.close()

kos = inquery.split('\n')
kos_d = {}
for item in kos:
	if '\t' in item:
		seqname = item.split('\t')[0]
		ko = item.split('\t')[1]
		if ko in kos_d:
			kos_d[ko].append(seqname)
		else:
			kos_d[ko]=[seqname]
	else:
		pass
print("queryKO file analyzed")

#fasta file is written and contigs are saved to seq_d
seq_d = {}
infasta = SeqIO.parse(fasta, 'fasta')
for seq in infasta:
	seq_d[seq.name] = seq.seq


infile = open(eclist)
searchedEC = infile.read()
infile.close()

ECs = searchedEC.split()

foundkos = []
foundnames = []
out = open('outfile.fasta', 'w')

for item in ECs:
	enzymedef = ECdef_d[item][0]
	for ortholog in ec_d[item]:
		if ortholog in kos_d:
			foundnames = kos_d[ortholog]
			for name in foundnames:
				sequence = seq_d[name]
				out.write(">%s %s_%s\n%s\n" % (name, item, enzymedef, sequence))		
		else:
			pass

out.close()

print("now dereplicating...")

output1 = open('outfile_dedupl_desc.fasta', 'w')
output2 = open('outfile_dupl_names.fasta', 'w')

# multiplications = {}
# seq_dict = {}
multiplications = defaultdict(list)
seq_dict = OrderedDict()
for sequence in SeqIO.parse('outfile.fasta', 'fasta'):
	if sequence.seq in multiplications:
		multiplications[sequence.seq].append(sequence.name)
	else:
		multiplications[sequence.seq] = [sequence.name]
	if sequence.seq not in seq_dict:
		#rename full header only with name (acc, till the first space)
		# seq_dict[sequence.seq] = sequence.name 
		#keep full header			
		seq_dict[sequence.seq] = sequence.description

for key, value in seq_dict.items():
	output1.write('>{}\n{}\n'.format(value, key))

for key, value in multiplications.items():
	if len(value) > 1:
		output2.write('{}\n'.format(str(value)))

output1.close()
output2.close()

print("dereplicated hits written to outfile_dedupl_desc.fasta")